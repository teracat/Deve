# This workflow requires the following GitHub secrets to be defined:
#
# Azure Container Registry (ACR) access:
# - ACR_LOGIN_SERVER: The login server URL of your Azure Container Registry (e.g., myregistry.azurecr.io).
# - ACR_USERNAME: The username for accessing the ACR (usually the registry name).
# - ACR_PASSWORD: The password or access key for the ACR.
#
# Azure Kubernetes Service (AKS) access:
# - AZURE_CREDENTIALS: A JSON string containing Azure service principal credentials, generated using `az ad sp create-for-rbac --sdk-auth`.
# - AKS_CLUSTER_NAME: The name of the AKS cluster to deploy to.
# - AKS_RESOURCE_GROUP: The name of the Azure resource group containing the AKS cluster.
#
# JWT Secret Keys:
# - JWT_SIGNING_SECRET_KEY: The secret key used to sign the JWT token (must be 32 bytes).
# - JWT_ENCRYPTION_SECRET_KEY: The secret key used to encrypt the JWT token (must be 32 bytes).
#
# Email notification settings:
# - SMTP_SERVER: The address of the SMTP server used to send emails (this is a variable, not a secret).
# - SMTP_PORT: The port used by the SMTP server (this is a variable, not a secret, e.g.: 587).
# - SMTP_USERNAME: The username of the SMTP account used to send notifications.
# - SMTP_PASSWORD: The password or app-specific password for the SMTP account.
# - EMAIL_TO: The recipient email address for deployment notifications (this is a variable, not a secret).
# - EMAIL_FROM: The sender email address used in deployment notifications (this is a variable, not a secret).
#
# Grafana:
# - GRAFANA_ADMIN_PASSWORD: Password of the admin user to access Grafana.
#
# DataSource:
# - APIINTERNAL_DATASOURCE_CONNECTIONSTRING: ConnectionString for your DataSource (Database) in api-internal.
# - APIEXTERNAL_DATASOURCE_CONNECTIONSTRING: ConnectionString for your DataSource (Database) in api-external.
#
# Let's Encrypt (these are variables, not secrets):
# - LETSENCRYPT_EMAIL: Email of the Let's Encrypt account.
# - HOST_APIINTERNAL: Host name for the Api Internal endpoint.
# - HOST_APIEXTERNAL: Host name for the Api External endpoint.
# - HOST_PROMETHEUS: Host name for the Prometheus endpoint.
# - HOST_GRAFANA: Host name for the Grafana endpoint.
# - HOST_ZIPKIN: Host name for the Zipkin endpoint.
# - HOST_OAUTH2: Host name for the OAuth2 endpoint.
# 
# OAuth2:
# - CLIENT_ID_GITHUB: OAuth Client ID provided by GitHub for your application (https://github.com/settings/applications).
# - CLIENT_SECRET_GITHUB: OAuth Client Secret used to authenticate your app with GitHub.
# - COOKIE_SECRET: 32-byte Base64 key used by oauth2-proxy to encrypt and sign session cookies.
# - EMAIL_DOMAIN_GITHUB: GitHub domain allowed to sign in (this is a variable, not a secret).

name: Deploy to Azure AKS

on:
  workflow_call:
    inputs:
      environment:
        description: "The GitHub environment used to get the secrets and vars needed"
        type: string
        required: true
      services:
        description: "Comma-separated list of services to deploy (e.g. api-internal,grafana)"
        type: string
        required: true

    secrets:
      ACR_LOGIN_SERVER:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      AZURE_CREDENTIALS:
        required: true
      AKS_CLUSTER_NAME:
        required: true
      AKS_RESOURCE_GROUP:
        required: true
      JWT_SIGNING_SECRET_KEY:
        required: true
      JWT_ENCRYPTION_SECRET_KEY:
        required: true
      SMTP_USERNAME:
        required: false
      SMTP_PASSWORD:
        required: false
      GRAFANA_ADMIN_PASSWORD:
        required: false
      APIINTERNAL_DATASOURCE_CONNECTIONSTRING:
        required: false
      APIEXTERNAL_DATASOURCE_CONNECTIONSTRING:
        required: false
      CLIENT_ID_GITHUB:
        required: true
      CLIENT_SECRET_GITHUB:
        required: true
      COOKIE_SECRET:
        required: true

# Only allow one deploy per environment
concurrency: ${{ inputs.environment }}

jobs:
  deploy-azure-aks:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    env:
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
    steps:
    - name: Check some secret
      run: |
          if [ -z "${{ secrets.ACR_USERNAME }}" ]; then
            echo "ACR_USERNAME is not defined"
            exit 1
          else
            echo "ACR_USERNAME is defined"
          fi

    - name: Check if SMTP_USERNAME is defined
      id: check_smtp
      run: |
        if [ -z "${{ secrets.SMTP_USERNAME }}" ]; then
          echo "defined=false" >> $GITHUB_OUTPUT
        else
          echo "defined=true" >> $GITHUB_OUTPUT
        fi

    - name: Checkout code
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  #v5.0.0

    - name: Define variables
      id: vars
      shell: bash
      run: |
        #Services        
        raw='${{ inputs.services }}'
        services=$(echo "$raw" | tr '\n' ',' | tr '[:upper:]' '[:lower:]' | sed -E 's/,+/,/g; s/^,+|,+$//g')
        services_spaces=$(echo "$services" | tr ',' ' ')
        
        echo "services=$services" >> "$GITHUB_OUTPUT"
        echo "services_spaces=$services_spaces" >> "$GITHUB_OUTPUT"

        #Compute IMAGE_TAG from tag or SHA
        IMAGE_TAG="${{ github.sha }}"

        REF_TYPE="${{ github.ref_type }}"
        REF_NAME="${{ github.ref_name }}"

        # If this is a tag and its last segment matches x.y.z, use that as the image tag
        if [[ "$REF_TYPE" == "tag" ]]; then
          if [[ "$REF_NAME" =~ ([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            IMAGE_TAG="${BASH_REMATCH[0]}"
          fi
        fi

        echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"

    - name: Login to ACR
      uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  #v3.6.0
      with:
        registry: ${{ secrets.ACR_LOGIN_SERVER }}  # ACR login server
        username: ${{ secrets.ACR_USERNAME }}  # ACR username
        password: ${{ secrets.ACR_PASSWORD }}  # ACR password

    - name: Build images with compose (tag computed)
      env:
        IMAGE_TAG: ${{ steps.vars.outputs.image_tag }}
      run: |
        docker compose -f .docker/compose.yml -f .docker/compose.prod.yml --project-directory .docker up --no-start ${{ steps.vars.outputs.services_spaces }}

    - name: Push docker images (tag computed)
      env:
        IMAGE_TAG: ${{ steps.vars.outputs.image_tag }}
      run: |
        docker compose -f .docker/compose.yml -f .docker/compose.prod.yml --project-directory .docker push --include-deps ${{ steps.vars.outputs.services_spaces }}

    - name: Build images with compose (tag latest)
      env:
        IMAGE_TAG: 'latest'
      run: |
        docker compose -f .docker/compose.yml -f .docker/compose.prod.yml --project-directory .docker up --no-start ${{ steps.vars.outputs.services_spaces }}

    - name: Push docker images (tag latest)
      env:
        IMAGE_TAG: 'latest'
      run: |
        docker compose -f .docker/compose.yml -f .docker/compose.prod.yml --project-directory .docker push --include-deps ${{ steps.vars.outputs.services_spaces }}

    - name: Azure login
      uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5  #v2.3.0
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context
      uses: azure/aks-set-context@c7eb093e5a5d47caa333f64974d5fd1cd4bf069d  #v4.0.3
      with:
        resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}

    - name: Check if ingress is needed
      id: ingress_needed
      run: |
        if [[ "${{ inputs.services }}" =~ "api-internal" || "${{ inputs.services }}" =~ "api-external" ]]; then
          echo "needed=true" >> $GITHUB_OUTPUT
        else
          echo "needed=false" >> $GITHUB_OUTPUT
        fi

    - name: Setup Helm
      uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 #v4.3.1

    - name: Install NGINX Ingress Controller if needed
      if: steps.ingress_needed.outputs.needed == 'true'
      run: |
        if ! kubectl get ns ingress-nginx >/dev/null 2>&1; then
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace
        else
          echo "NGINX Ingress Controller already installed"
        fi

    - name: Install cert-manager if needed
      if: steps.ingress_needed.outputs.needed == 'true'
      run: |
        if ! kubectl get ns cert-manager >/dev/null 2>&1; then
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --set installCRDs=true
        else
          echo "cert-manager already installed"
        fi

    - name: Create Helm file with secrets
      run: |
        cat > helm-values.override.yaml << 'EOF'
        services:
          apiInternal:
            dataSourceConnectionString: "${{ secrets.APIINTERNAL_DATASOURCE_CONNECTIONSTRING }}"
            jwtSigningSecretKey: "${{ secrets.JWT_SIGNING_SECRET_KEY }}"
            jwtEncryptionSecretKey: "${{ secrets.JWT_ENCRYPTION_SECRET_KEY }}"
            host: "${{ vars.HOST_APIINTERNAL }}"
          apiExternal:
            dataSourceConnectionString: "${{ secrets.APIEXTERNAL_DATASOURCE_CONNECTIONSTRING }}"
            jwtSigningSecretKey: "${{ secrets.JWT_SIGNING_SECRET_KEY }}"
            jwtEncryptionSecretKey: "${{ secrets.JWT_ENCRYPTION_SECRET_KEY }}"
            host: "${{ vars.HOST_APIEXTERNAL }}"
          prometheus:
            host: "${{ vars.HOST_PROMETHEUS }}"
          grafana:
            host: "${{ vars.HOST_GRAFANA }}"
          zipkin:
            host: "${{ vars.HOST_ZIPKIN }}"
          oauth2:
            host: "${{ vars.HOST_OAUTH2 }}"
            hostRoot: "${{ vars.HOST_ROOT }}"
            clientIdGitHub: "${{ secrets.CLIENT_ID_GITHUB }}"
            clientSecretGitHub: "${{ secrets.CLIENT_SECRET_GITHUB }}"
            cookieSecret: "${{ secrets.COOKIE_SECRET }}"
            emailDomainGitHub: "${{ vars.EMAIL_DOMAIN_GITHUB }}"
          letsEncrypt:
            email: "${{ vars.LETSENCRYPT_EMAIL }}"
        EOF

    - name: Deploy with Helm
      run: |
        helm upgrade services .github/helm \
              -f .github/helm/values.yaml \
              -f helm-values.override.yaml \
              --install \
              --debug \
              --set acrLoginServer=${{ secrets.ACR_LOGIN_SERVER }} \
              --set image.tag=latest \
              --set "deploy.enabledServices={${{ steps.vars.outputs.services }}}"

    - name: Send Success Notification
      if: steps.check_smtp.outputs.defined == 'true' && success()
      uses: dawidd6/action-send-mail@6d98ae34d733f9a723a9e04e94f2f24ba05e1402 #v6
      with:
        server_address: ${{ vars.SMTP_SERVER }}
        server_port: ${{ vars.SMTP_PORT }}
        username: ${{ secrets.SMTP_USERNAME }}
        password: ${{ secrets.SMTP_PASSWORD }}
        subject: "Deployment to ${{ inputs.environment }} Successful"
        body: "The deployment to ${{ inputs.environment }} has been successfully completed."
        to: ${{ vars.EMAIL_TO }}
        from: ${{ vars.EMAIL_FROM }}

    - name: Send Failure Notification
      if: steps.check_smtp.outputs.defined == 'true' && failure()
      uses: dawidd6/action-send-mail@6d98ae34d733f9a723a9e04e94f2f24ba05e1402 #v6
      with:
        server_address: ${{ vars.SMTP_SERVER }}
        server_port: ${{ vars.SMTP_PORT }}
        username: ${{ secrets.SMTP_USERNAME }}
        password: ${{ secrets.SMTP_PASSWORD }}
        subject: "Deployment to ${{ inputs.environment }} Failed"
        body: "The deployment to ${{ inputs.environment }} has failed."
        to: ${{ vars.EMAIL_TO }}
        from: ${{ vars.EMAIL_FROM }}
